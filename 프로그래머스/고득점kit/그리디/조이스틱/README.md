## 해설
[블로그](https://jokerldg.github.io/algorithm/2021/05/24/joystick.html)  
1. 각 알파벳마다 상하 조정 중 min값으로 최소 횟수를 담아두는 배열을 만든다. 
2. 0번 idx부터 시작해서 좌우 이동 횟수를 answer에 더해준다. 
3. 좌우 방향 전환 시에는 바꿔야 하는 알파벳이 나오기까지의 좌우 거리를 구한뒤, 그 중 최솟값이 되는 방향으로 전환한다. (**여기가 그리디의 핵심**)
4. 모든 알파벳이 조정된 경우(change 배열이 전부 0인경우) 결과값을 반환한다.
---


## input && output
```
name
"JEROEN"

return
AAAAAA에서 JEROEN 만들려먼 조이스틱 몇번 움직여야 하는가
56
```

## notes
```
알파벳이동 & 커서이동
```

## strategy
```
최소로..이동시킨다라...
1. A가 아닌 알파벳은 무조건 거쳐가야함.
2. 그래서 A를 최대한 안지나가도록 설계해야 함.
가설. 가장 긴 A로만 이뤄진 부분문자열을 찾은 다음에, 거기까지의 최단거리로 생각해서 작업 고.
조금 더 구체적으로 나열하자면

0. 알파벳 바꾸는 횟수는 첨부터 끝까지 함수 돌려서 다 계산해놓는다. 결국 중요한건 좌우이동을 최소화하는 것이다.
1. A로만 이뤄진 부분문자열 중 가장 긴 곳을 찾는다.
2. 그 중 왼쪽이든 오른쪽이든 더 빨리 닿는 곳을 고른다.
3. 짧은거리*2 + 긴거리 더해주고 끝낸다.
(거리라 함은 사이에 낑긴 A아닌 알파벳 수. 일반적으로 생각하는 거리 - 1) 


아오 근데 이 방법은 아닌 것 같아서 답을 봐야겠다.
```
