

## 해설
[블로그](https://khann.tistory.com/79)    
최단depth로 탐색할 때 bfs를 쓴것처럼,  
이런 상황에선 dfs를 쓸 수 있다는 건 깨달았다.  
뎁쓰는 계속 올라가므로 찾자마자 리턴할 수 있는 점.  
사실 말로 표현하긴 어렵고 코드를 보도록 하자.  
이 문제도 복습각.  
프로그래머스 문제들이 뭐랄까 하나하나 어려운데 주옥같다.
---


## input
```
begin
"hit"

target
"cog"

words
["hot", "dot", "dog", "lot", "log", "cog"]
```

## output
```
최소 몇 단계의 과정을 거쳐 begin->target으로 변환할 수 있는가?
4
```

## notes
```
1. 한번에 알파벳 하나 변환
2. words에 있는 단어로만.
3. 변환할 수 없는 경우 0 리턴

begin은 없어도 되고 target은 있어야함.
각 단어 길이는 같고 ㅇㅇ.
중복되는 단어는 없다.


```

## strategy
```
어렵다.
항상 이런 최적화 문제가 제일 어려운것같다.
그리고 대충 백트래킹 dfs 냄새가 난다.

1. 일단 현 단어에서 갈 수 있는 경로를 골라야 한다.
hit에서 출발한다면 xit? hxt? hix? 각 별로 뽑아내고
각각에 대해 하나만 딥따 파야 하는데
이건 해설을 보는 게 낫겠다.

2. 그 경로를 dfs든 bfs든 완전탐색적으로 들어가서
3. target이 되는 순간 answer에 min처리해주면 될 것이다.

```
