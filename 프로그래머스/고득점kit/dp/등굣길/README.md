## input & output
```
c
4

r
3

puddles(c, r)
[[2,2]]

return
0,0에서 r,c까지 가는 최단경로 개수
4

```

## notes
```
가장 왼쪽 위를 1,1로 표현함.
1000000007로 나눈 나머지 리턴

```

## strategy
```
dp로 하면 될 것 같다.
0. dp_t는 0으로 싹 초기화해준다. r+1 * c+1 크기면 충분. 퍼들부분은 INF로. 채워나가는 중에 INF 만나면 그냥 스킵
1. 0,0부터 시작해서 그냥 쭉.. r, c 반복시킨다.
2. min(dp_t[r-1][c], dp_t[r][c-1])+1 해주고, 경계처리는 잘 해주자.

경계처리는 특별히 할 것 없이 r=0 부분과 c=0 부분을 INF로 해주면 알아서 걸러짐.
이 문제는 운좋게도 1,1부터 출발한다고 되어있어서 지도사이즈를 늘릴 생각을 했지만,
평소에도 경계처리 vs 지도사이즈늘리기의 아이디어를 갖고 있는다면 좋을 것.

근데 다시보니 거리가 아닌 개수구나.
음.. dp_t를 채워나갈 때 위와 왼쪽이 모두 뚫려있으면 +=1, 한쪽만 뚫려있으면 그 중 max값.

```
